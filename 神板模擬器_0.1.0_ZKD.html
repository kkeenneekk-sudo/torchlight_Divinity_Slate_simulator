<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>神板佈置模擬器 v0.1.0 - 由 ZKD 開發</title>
    <meta name="description" content="專為玩家設計的神板佈置模擬工具，輕鬆規劃最佳盤面佈局。">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 10px; }
        * { -webkit-touch-callout: none; -webkit-user-select: none; }
    </style>
</head>
<body class="bg-slate-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;

        const Icon = ({ name, size = 18, className = "" }) => {
            useEffect(() => { if (window.lucide) window.lucide.createIcons(); });
            return <i data-lucide={name} className={className} style={{ width: size, height: size }}></i>;
        };

        const GRID_SIZE = 6;
        const CELL_DISPLAY_SIZE = 55;
        const GAP = 6;

        const isOriginalZone = (r, c) => {
            const inCenter = (r >= 1 && r <= 4 && c >= 1 && c <= 4);
            const inTop = (r === 0 && (c === 2 || c === 3));
            const inBottom = (r === 5 && (c === 2 || c === 3));
            const inLeft = ((r === 2 || r === 3) && c === 0);
            const inRight = ((r === 2 || r === 3) && c === 5);
            return inCenter || inTop || inBottom || inLeft || inRight;
        };

        const PIECE_TYPES = {
            BASIC_SQ: { id: 'BASIC_SQ', name: '基礎神板 (2x2)', cells: [[0,0], [0,1], [1,0], [1,1]], color: '#4f46e5', limit: 99 },
            BASIC_L: { id: 'BASIC_L', name: '基礎神板 (L4)', cells: [[0,0], [1,0], [2,0], [2,1]], color: '#6366f1', limit: 99, canMirror: true },
            BASIC_T: { id: 'BASIC_T', name: '基礎神板 (T)', cells: [[0,0], [0,1], [0,2], [1,1]], color: '#818cf8', limit: 99 },
            BASIC_Z: { id: 'BASIC_Z', name: '基礎神板 (Z)', cells: [[0,0], [0,1], [1,1], [1,2]], color: '#4338ca', limit: 99, canMirror: true },
            TRIANGLE: { id: 'TRIANGLE', name: '神性一角 (L3)', cells: [[0,0], [1,0], [1,1]], color: '#10b981', limit: 3 },
            SMALL_FRY: { id: 'SMALL_FRY', name: '群星輝隕 (1x2)', cells: [[0,0], [0,1]], color: '#f59e0b', limit: 3 },
            BIG_FRY: { id: 'BIG_FRY', name: '寰空神隙 (1x6)', cells: [[0,0], [0,1], [0,2], [0,3], [0,4], [0,5]], color: '#ef4444', limit: 1 },
            GOD_BOARD: { id: 'GOD_BOARD', name: '神之譜系 (7格)', cells: [[0,0], [0,1], [1,0], [1,1], [1,2], [2,1], [2,2]], color: '#ec4899', limit: 1 },
            WINDMILL: { id: 'WINDMILL', name: '眾星歸所 (8格)', cells: [[1,1], [1,2], [2,1], [2,2], [0,1], [1,3], [3,2], [2,0]], color: '#8b5cf6', limit: 99 },
            MOTH: { id: 'MOTH', name: '星星蛾火燎原之刻 (1x1)', cells: [[0,0]], color: '#d946ef', limit: 4 }
        };

        const PieceMiniPreview = ({ cells, color, size = 10 }) => {
            const rows = cells.map(c => c[0]), cols = cells.map(c => c[1]);
            const minR = Math.min(...rows), maxR = Math.max(...rows);
            const minC = Math.min(...cols), maxC = Math.max(...cols);
            const width = maxC - minC + 1, height = maxR - minR + 1;
            return (
                <div className="grid gap-[1px] p-1 bg-slate-900/50 rounded" style={{ gridTemplateColumns: `repeat(${width}, ${size}px)` }}>
                    {[...Array(height)].map((_, r) => [...Array(width)].map((_, c) => {
                        const isFilled = cells.some(cell => cell[0] - minR === r && cell[1] - minC === c);
                        return <div key={`${r}-${c}`} style={{ width: size, height: size, backgroundColor: isFilled ? color : 'transparent' }} />
                    }))}
                </div>
            );
        };

        const App = () => {
            const [placedPieces, setPlacedPieces] = useState([]);
            const [selectedType, setSelectedType] = useState(null); 
            const [currentCells, setCurrentCells] = useState([]);   
            const [hoverPos, setHoverPos] = useState({ r: 2, c: 2 });
            const [originPos, setOriginPos] = useState({ r: 2, c: 2 });
            const [grabOffset, setGrabOffset] = useState({ r: 0, c: 0 });

            const gridOccupancy = useMemo(() => {
                const grid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                placedPieces.forEach(piece => {
                    piece.cells.forEach(([dr, dc]) => {
                        const nr = piece.rootR + dr, nc = piece.rootC + dc;
                        if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) grid[nr][nc]++;
                    });
                });
                return grid;
            }, [placedPieces]);

            const hasOverlap = useMemo(() => gridOccupancy.some(row => row.some(count => count > 1)), [gridOccupancy]);
            const hasPlacementError = placedPieces.some(piece => piece.cells.some(([dr, dc]) => !isOriginalZone(piece.rootR + dr, piece.rootC + dc)));
            const counts = placedPieces.reduce((acc, p) => { acc[p.typeId] = (acc[p.typeId] || 0) + 1; return acc; }, {});

            const handleRotateActive = useCallback(() => {
                if (selectedType) {
                    setCurrentCells(prev => prev.map(([r, c]) => [c - grabOffset.c + grabOffset.r, -(r - grabOffset.r) + grabOffset.c]));
                }
            }, [selectedType, grabOffset]);

            const toggleMirror = () => {
                if (selectedType) {
                    setCurrentCells(prev => prev.map(([r, c]) => [r, -(c - grabOffset.c) + grabOffset.c]));
                }
            };

            const handleDiscard = () => { 
                setSelectedType(null); setCurrentCells([]); setGrabOffset({ r: 0, c: 0 }); 
            };

            const handleSelectMenuType = (type) => {
                if (selectedType?.id === type.id) handleDiscard();
                else {
                    const rows = type.cells.map(c => c[0]), cols = type.cells.map(c => c[1]);
                    const offset = { r: Math.floor((Math.min(...rows) + Math.max(...rows)) / 2), c: Math.floor((Math.min(...cols) + Math.max(...cols)) / 2) };
                    setSelectedType(type); 
                    setCurrentCells(type.cells); 
                    setGrabOffset(offset);
                    setHoverPos({ r: 2, c: 2 });
                    setOriginPos({ r: 2, c: 2 });
                }
            };

            const onCellClick = (r, c) => {
                const rootR = r - grabOffset.r, rootC = c - grabOffset.c;
                if (selectedType) {
                    if (currentCells.every(([dr, dc]) => (rootR + dr) >= 0 && (rootR + dr) < GRID_SIZE && (rootC + dc) >= 0 && (rootC + dc) < GRID_SIZE)) {
                        setPlacedPieces(prev => [...prev, { instanceId: `p-${Date.now()}-${Math.random()}`, typeId: selectedType.id, rootR, rootC, cells: [...currentCells], color: selectedType.color }]);
                        handleDiscard();
                    }
                } else {
                    const idx = [...placedPieces].reverse().findIndex(p => p.cells.some(([dr, dc]) => p.rootR + dr === r && p.rootC + dc === c));
                    if (idx !== -1) {
                        const actualIdx = placedPieces.length - 1 - idx;
                        const p = placedPieces[actualIdx];
                        setGrabOffset({ r: r - p.rootR, c: c - p.rootC });
                        setPlacedPieces(prev => prev.filter((_, i) => i !== actualIdx));
                        setSelectedType(PIECE_TYPES[p.typeId]); 
                        setCurrentCells(p.cells);
                        setHoverPos({ r, c });
                        setOriginPos({ r, c });
                    }
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    const k = e.key.toLowerCase();
                    if (k === 'r') handleRotateActive();
                    if (k === 'm') toggleMirror();
                    if (['escape', 'delete', 'backspace'].includes(k)) handleDiscard();
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleRotateActive, selectedType]);

            const hasNeighbor = (cells, dr, dc, dir) => cells.some(([r, c]) => r === dr + dir[0] && c === dc + dir[1]);

            return (
                <div className="flex flex-col items-center min-h-screen p-4 text-slate-100 select-none">
                    <div className="max-w-6xl w-full">
                        <header className="mb-6 flex justify-between items-end border-b border-slate-700 pb-4">
                            <div className="flex flex-col">
                                <h1 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-orange-400 to-yellow-200 mb-2">
                                    神板佈置模擬器 <span className="text-sm font-normal text-slate-500">v0.1.0</span>
                                </h1>
                                <div className="flex flex-col gap-1 text-xs text-slate-400 font-medium">
                                    <div className="flex items-center gap-2">
                                        <Icon name="user" size={12} className="text-cyan-400"/> 開發者：ZKD
                                        <span className="mx-1">|</span>
                                        開發工具：Google Gemini
                                    </div>
                                    <div className="flex gap-4 mt-1">
                                        <a href="https://www.youtube.com/@zkd_yt" target="_blank" className="text-red-600 hover:text-red-500 transition-colors flex items-center gap-1 font-bold"><Icon name="youtube" size={12}/> YouTube @ZKD</a>
                                        <a href="https://www.twitch.tv/zkdeng" target="_blank" className="text-purple-600 hover:text-purple-500 transition-colors flex items-center gap-1 font-bold"><Icon name="twitch" size={12}/> Twitch @zkdeng</a>
                                    </div>
                                </div>
                            </div>
                            <button onClick={() => setPlacedPieces([])} className="bg-slate-800 text-red-400 px-4 py-2 rounded-lg border border-red-900/50 hover:bg-red-900/20 active:scale-95 transition-all text-sm font-bold">重置</button>
                        </header>

                        <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
                            <div className="lg:col-span-4 flex flex-col gap-6">
                                <div className="bg-slate-800/50 p-5 rounded-2xl border border-slate-700 shadow-xl">
                                    <h2 className="text-sm font-bold mb-4 flex items-center gap-2 text-blue-400 uppercase tracking-wider"><Icon name="package" size={16}/> 神板倉庫</h2>
                                    <div className="space-y-2 overflow-y-auto max-h-[50vh] pr-2 custom-scrollbar">
                                        {Object.values(PIECE_TYPES).map(type => {
                                            const current = counts[type.id] || 0;
                                            const isMax = current >= type.limit;
                                            const isSelected = selectedType?.id === type.id;
                                            return (
                                                <button key={type.id} disabled={isMax && !isSelected} onClick={() => handleSelectMenuType(type)} className={`w-full p-3 rounded-xl border-2 text-left flex items-center gap-4 transition-all ${isSelected ? 'border-orange-500 bg-orange-500/10' : isMax ? 'opacity-30 border-slate-800 cursor-not-allowed' : 'border-slate-700 bg-slate-800 hover:border-slate-500'}`}>
                                                    <PieceMiniPreview cells={type.cells} color={type.color} size={7} />
                                                    <div className="flex-1 min-w-0">
                                                        <div className="font-bold text-xs truncate">{type.name}</div>
                                                        <div className={`text-[10px] mt-0.5 ${isMax ? 'text-red-400' : 'text-slate-500'}`}>{current}/{type.limit === 99 ? '∞' : type.limit}</div>
                                                    </div>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                                <div onClick={handleDiscard} className={`p-6 rounded-2xl border-2 border-dashed flex flex-col items-center justify-center gap-2 transition-all cursor-pointer ${selectedType ? 'bg-red-500/20 border-red-500 text-red-400' : 'bg-slate-800/30 border-slate-700 text-slate-600 hover:text-slate-500'}`}>
                                    <Icon name="trash-2" size={selectedType ? 32 : 24} />
                                    <span className="text-[10px] font-bold uppercase">{selectedType ? '放棄選取' : '垃圾桶'}</span>
                                </div>
                            </div>

                            <div className="lg:col-span-8 flex flex-col items-center">
                                <div className="h-10 mb-2 flex items-center gap-4">
                                    {hasOverlap && <div className="px-4 py-1.5 rounded-full bg-red-500 text-white text-[10px] font-bold animate-pulse">神板發生重疊</div>}
                                    {hasPlacementError && <div className="px-4 py-1.5 rounded-full bg-orange-500 text-white text-[10px] font-bold">超出佈置區域</div>}
                                </div>

                                <div 
                                    className="relative bg-slate-950 p-6 rounded-[2.5rem] border-[10px] border-slate-800 shadow-2xl touch-none"
                                    onMouseLeave={() => setHoverPos(originPos)}
                                >
                                    <div className="grid gap-[6px]" style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, ${CELL_DISPLAY_SIZE}px)` }}>
                                        {[...Array(GRID_SIZE * GRID_SIZE)].map((_, i) => {
                                            const r = Math.floor(i / GRID_SIZE), c = i % GRID_SIZE;
                                            return <div key={i} onMouseEnter={() => setHoverPos({r, c})} onTouchStart={() => setHoverPos({r, c})} onClick={() => onCellClick(r, c)} className={`w-[${CELL_DISPLAY_SIZE}px] h-[${CELL_DISPLAY_SIZE}px] rounded-lg border border-slate-700/20 cursor-pointer transition-colors ${isOriginalZone(r, c) ? 'bg-slate-800 shadow-inner' : 'bg-slate-900/30'}`} style={{ width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE }} />
                                        })}
                                    </div>
                                    
                                    {selectedType && (
                                        <div className="absolute inset-0 p-6 pointer-events-none z-40">
                                            {currentCells.map(([dr, dc], idx) => {
                                                const nr = hoverPos.r - grabOffset.r + dr, nc = hoverPos.c - grabOffset.c + dc;
                                                if (nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE) return null;
                                                const overlap = gridOccupancy[nr][nc] > 0;
                                                return <div key={idx} className={`absolute rounded-lg border-2 shadow-2xl transition-all duration-200 ${overlap ? 'border-red-400' : 'border-white'}`} style={{ width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE, left: nc * (CELL_DISPLAY_SIZE + GAP), top: nr * (CELL_DISPLAY_SIZE + GAP), backgroundColor: overlap ? 'rgba(239, 68, 68, 0.5)' : `${selectedType.color}cc` }} />
                                            })}
                                        </div>
                                    )}

                                    <div className="absolute inset-0 p-6 pointer-events-none">
                                        {placedPieces.map(piece => (
                                            <div key={piece.instanceId} className="relative">
                                                {piece.cells.map(([dr, dc], ci) => {
                                                    const t = hasNeighbor(piece.cells, dr, dc, [-1, 0]), b = hasNeighbor(piece.cells, dr, dc, [1, 0]);
                                                    const l = hasNeighbor(piece.cells, dr, dc, [0, -1]), r = hasNeighbor(piece.cells, dr, dc, [0, 1]);
                                                    return <div key={ci} className="absolute z-20 border-[2.5px] border-white shadow-md" style={{ 
                                                        width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE, 
                                                        left: (piece.rootC + dc) * (CELL_DISPLAY_SIZE + GAP), top: (piece.rootR + dr) * (CELL_DISPLAY_SIZE + GAP), 
                                                        backgroundColor: piece.color,
                                                        borderTop: t ? 'none' : '', borderBottom: b ? 'none' : '', borderLeft: l ? 'none' : '', borderRight: r ? 'none' : '',
                                                        borderRadius: `${!t&&!l?'8px':'0'} ${!t&&!r?'8px':'0'} ${!b&&!r?'8px':'0'} ${!b&&!l?'8px':'0'}`
                                                    }} />
                                                })}
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                <div className="mt-8 flex gap-4 w-full max-w-sm justify-center">
                                    <button onClick={handleRotateActive} disabled={!selectedType} className={`flex flex-col items-center justify-center w-24 h-24 rounded-2xl border-2 transition-all active:scale-95 shadow-xl ${selectedType ? 'bg-slate-800 border-cyan-500 text-cyan-400' : 'bg-slate-900/50 border-slate-800 text-slate-700 opacity-50'}`}>
                                        <Icon name="rotate-cw" size={32} />
                                        <span className="mt-2 font-bold text-xs">旋轉 (R)</span>
                                    </button>
                                    <button onClick={toggleMirror} disabled={!selectedType} className={`flex flex-col items-center justify-center w-24 h-24 rounded-2xl border-2 transition-all active:scale-95 shadow-xl ${selectedType ? 'bg-slate-800 border-purple-500 text-purple-400' : 'bg-slate-900/50 border-slate-800 text-slate-700 opacity-50'}`}>
                                        <Icon name="flip-horizontal" size={32} />
                                        <span className="mt-2 font-bold text-xs">鏡像 (M)</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
