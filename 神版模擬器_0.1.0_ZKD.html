<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>神板佈置模擬器 v0.1.0</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 React 與 Babel -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 引入 Lucide 圖標庫 -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 10px; }
    </style>
</head>
<body class="bg-slate-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;

        // 圖標組件封裝
        const Icon = ({ name, size = 18, className = "" }) => {
            useEffect(() => {
                if (window.lucide) {
                    window.lucide.createIcons();
                }
            });
            return <i data-lucide={name} className={className} style={{ width: size, height: size }}></i>;
        };

        const GRID_SIZE = 6;
        const CELL_DISPLAY_SIZE = 55;
        const GAP = 6;

        const isOriginalZone = (r, c) => {
            const inCenter = (r >= 1 && r <= 4 && c >= 1 && c <= 4);
            const inTop = (r === 0 && (c === 2 || c === 3));
            const inBottom = (r === 5 && (c === 2 || c === 3));
            const inLeft = ((r === 2 || r === 3) && c === 0);
            const inRight = ((r === 2 || r === 3) && c === 5);
            return inCenter || inTop || inBottom || inLeft || inRight;
        };

        const PIECE_TYPES = {
            BASIC_SQ: { id: 'BASIC_SQ', name: '基礎型 (2x2)', cells: [[0,0], [0,1], [1,0], [1,1]], color: '#4f46e5', limit: 99 },
            BASIC_L: { id: 'BASIC_L', name: '基礎型 (L4)', cells: [[0,0], [1,0], [2,0], [2,1]], color: '#6366f1', limit: 99, canMirror: true },
            BASIC_T: { id: 'BASIC_T', name: '基礎型 (T)', cells: [[0,0], [0,1], [0,2], [1,1]], color: '#818cf8', limit: 99 },
            BASIC_Z: { id: 'BASIC_Z', name: '基礎型 (Z)', cells: [[0,0], [0,1], [1,1], [1,2]], color: '#4338ca', limit: 99, canMirror: true },
            TRIANGLE: { id: 'TRIANGLE', name: '三角型 (L3)', cells: [[0,0], [1,0], [1,1]], color: '#10b981', limit: 3 },
            SMALL_FRY: { id: 'SMALL_FRY', name: '小薯條 (1x2)', cells: [[0,0], [0,1]], color: '#f59e0b', limit: 3 },
            BIG_FRY: { id: 'BIG_FRY', name: '大薯條 (1x6)', cells: [[0,0], [0,1], [0,2], [0,3], [0,4], [0,5]], color: '#ef4444', limit: 1 },
            GOD_BOARD: { id: 'GOD_BOARD', name: '大神板 (7格)', cells: [[0,0], [0,1], [1,0], [1,1], [1,2], [2,1], [2,2]], color: '#ec4899', limit: 1 },
            WINDMILL: { id: 'WINDMILL', name: '大風車 (8格)', cells: [[1,1], [1,2], [2,1], [2,2], [0,1], [1,3], [3,2], [2,0]], color: '#8b5cf6', limit: 99 },
            MOTH: { id: 'MOTH', name: '蛾火 (1x1)', cells: [[0,0]], color: '#d946ef', limit: 4 }
        };

        const PieceMiniPreview = ({ cells, color, size = 10 }) => {
            const rows = cells.map(c => c[0]);
            const cols = cells.map(c => c[1]);
            const minR = Math.min(...rows);
            const maxR = Math.max(...rows);
            const minC = Math.min(...cols);
            const maxC = Math.max(...cols);
            const width = maxC - minC + 1;
            const height = maxR - minR + 1;
            
            return (
                <div className="grid gap-[1px] p-1 bg-slate-900/50 rounded" style={{ gridTemplateColumns: `repeat(${width}, ${size}px)` }}>
                    {[...Array(height)].map((_, r) => 
                        [...Array(width)].map((_, c) => {
                            const isFilled = cells.some(cell => cell[0] - minR === r && cell[1] - minC === c);
                            return <div key={`${r}-${c}`} style={{ width: size, height: size, backgroundColor: isFilled ? color : 'transparent' }} />
                        })
                    )}
                </div>
            );
        };

        const App = () => {
            const [placedPieces, setPlacedPieces] = useState([]);
            const [selectedType, setSelectedType] = useState(null); 
            const [currentCells, setCurrentCells] = useState([]);   
            const [hoverPos, setHoverPos] = useState(null);         
            const [isMirrored, setIsMirrored] = useState(false);
            const [grabOffset, setGrabOffset] = useState({ r: 0, c: 0 });

            const gridOccupancy = useMemo(() => {
                const grid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                placedPieces.forEach(piece => {
                    piece.cells.forEach(([dr, dc]) => {
                        const nr = piece.rootR + dr;
                        const nc = piece.rootC + dc;
                        if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) grid[nr][nc]++;
                    });
                });
                return grid;
            }, [placedPieces]);

            const hasOverlap = useMemo(() => gridOccupancy.some(row => row.some(count => count > 1)), [gridOccupancy]);
            const hasPlacementError = placedPieces.some(piece => piece.cells.some(([dr, dc]) => !isOriginalZone(piece.rootR + dr, piece.rootC + dc)));
            const counts = placedPieces.reduce((acc, p) => { acc[p.typeId] = (acc[p.typeId] || 0) + 1; return acc; }, {});

            const handleRotateActive = useCallback(() => {
                if (selectedType) {
                    setCurrentCells(prev => prev.map(([r, c]) => [c - grabOffset.c + grabOffset.r, -(r - grabOffset.r) + grabOffset.c]));
                }
            }, [selectedType, grabOffset]);

            const toggleMirror = () => {
                if (selectedType) {
                    setIsMirrored(!isMirrored);
                    setCurrentCells(prev => prev.map(([r, c]) => [r, -(c - grabOffset.c) + grabOffset.c]));
                }
            };

            const handleDiscard = () => { setSelectedType(null); setCurrentCells([]); setIsMirrored(false); setGrabOffset({ r: 0, c: 0 }); };

            const handleSelectMenuType = (type) => {
                if (selectedType?.id === type.id) handleDiscard();
                else {
                    const rows = type.cells.map(c => c[0]);
                    const cols = type.cells.map(c => c[1]);
                    const offset = { r: Math.floor((Math.min(...rows) + Math.max(...rows)) / 2), c: Math.floor((Math.min(...cols) + Math.max(...cols)) / 2) };
                    setSelectedType(type); setCurrentCells(type.cells); setIsMirrored(false); setGrabOffset(offset);
                }
            };

            const onCellClick = (r, c) => {
                const rootR = r - grabOffset.r;
                const rootC = c - grabOffset.c;
                if (selectedType) {
                    if (currentCells.every(([dr, dc]) => (rootR + dr) >= 0 && (rootR + dr) < GRID_SIZE && (rootC + dc) >= 0 && (rootC + dc) < GRID_SIZE)) {
                        setPlacedPieces(prev => [...prev, { instanceId: `p-${Date.now()}-${Math.random()}`, typeId: selectedType.id, rootR, rootC, cells: [...currentCells], color: selectedType.color, canMirror: selectedType.canMirror }]);
                        handleDiscard();
                    }
                } else {
                    const idx = [...placedPieces].reverse().findIndex(p => p.cells.some(([dr, dc]) => p.rootR + dr === r && p.rootC + dc === c));
                    if (idx !== -1) {
                        const actualIdx = placedPieces.length - 1 - idx;
                        const p = placedPieces[actualIdx];
                        setGrabOffset({ r: r - p.rootR, c: c - p.rootC });
                        setPlacedPieces(prev => prev.filter((_, i) => i !== actualIdx));
                        setSelectedType(PIECE_TYPES[p.typeId]); setCurrentCells(p.cells);
                    }
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    const k = e.key.toLowerCase();
                    if (k === 'r') handleRotateActive();
                    if (k === 'm') toggleMirror();
                    if (['escape', 'delete', 'backspace'].includes(k)) handleDiscard();
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleRotateActive, selectedType]);

            const hasNeighbor = (cells, dr, dc, dir) => cells.some(([r, c]) => r === dr + dir[0] && c === dc + dir[1]);

            return (
                <div className="flex flex-col items-center min-h-screen p-4 text-slate-100 select-none">
                    <div className="max-w-6xl w-full">
                        <header className="mb-6 flex justify-between items-end border-b border-slate-700 pb-4">
                            <div className="flex flex-col">
                                <div className="flex items-center gap-3 mb-1">
                                    <h1 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-orange-400 to-yellow-200">
                                        神板佈置模擬器
                                    </h1>
                                    <span className="text-slate-500 text-xs font-mono mt-2 self-start bg-slate-800 px-2 py-0.5 rounded border border-slate-700">v0.1.0</span>
                                </div>
                                <div className="flex flex-col gap-1">
                                    <div className="flex items-center gap-2 text-slate-300 text-sm font-semibold">
                                        <Icon name="user" size={14} className="text-cyan-400" />
                                        開發者：ZKD
                                    </div>
                                    <a 
                                        href="https://www.youtube.com/@zkd_yt" 
                                        target="_blank" 
                                        rel="noopener noreferrer"
                                        className="flex items-center gap-2 text-red-400 hover:text-red-300 transition-colors text-xs"
                                    >
                                        <Icon name="youtube" size={14} />
                                        ZKD - YouTube 頻道
                                    </a>
                                </div>
                            </div>
                            <button onClick={() => setPlacedPieces([])} className="flex items-center gap-2 bg-slate-800 hover:bg-red-900/40 text-red-400 px-4 py-2 rounded-lg border border-red-900/50 transition-all shadow-lg active:scale-95">
                                <Icon name="refresh-cw" /> 重置盤面
                            </button>
                        </header>

                        <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
                            <div className="lg:col-span-4 flex flex-col gap-6">
                                <div className="bg-slate-800/50 p-6 rounded-2xl border border-slate-700 shadow-xl">
                                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2 text-blue-400"><Icon name="info" /> 神板選單</h2>
                                    <div className="space-y-3 overflow-y-auto max-h-[60vh] pr-2 custom-scrollbar">
                                        {Object.values(PIECE_TYPES).map(type => {
                                            const current = counts[type.id] || 0;
                                            const isMax = current >= type.limit;
                                            const isSelected = selectedType?.id === type.id;
                                            return (
                                                <div key={type.id} className="space-y-2">
                                                    <button disabled={isMax && !isSelected} onClick={() => handleSelectMenuType(type)} className={`w-full p-3 rounded-xl border-2 text-left flex items-center gap-4 transition-all ${isSelected ? 'border-orange-500 bg-orange-500/10 shadow-[0_0_15px_rgba(249,115,22,0.2)]' : isMax ? 'opacity-40 grayscale border-slate-700 cursor-not-allowed' : 'border-slate-700 bg-slate-800 hover:bg-slate-700 hover:border-slate-500'}`}>
                                                        <div className="w-12 h-12 flex items-center justify-center shrink-0">
                                                            <PieceMiniPreview cells={type.cells} color={type.color} size={8} />
                                                        </div>
                                                        <div className="flex-1 min-w-0">
                                                            <div className="font-bold text-sm truncate">{type.name}</div>
                                                            <div className={`text-xs mt-1 font-mono ${isMax ? 'text-red-400' : 'text-slate-500'}`}>已放置: {current}/{type.limit === 99 ? '∞' : type.limit}</div>
                                                        </div>
                                                    </button>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                <div onClick={handleDiscard} className={`p-6 rounded-2xl border-2 border-dashed flex flex-col items-center justify-center gap-2 transition-all cursor-pointer ${selectedType ? 'bg-red-500/20 border-red-500 text-red-400 shadow-lg' : 'bg-slate-800/30 border-slate-700 text-slate-600 hover:text-slate-500'}`}>
                                    <Icon name="trash-2" size={selectedType ? 40 : 28} className={selectedType ? 'animate-bounce' : ''} />
                                    <span className="text-[10px] font-bold uppercase tracking-widest">{selectedType ? '點擊此處丟棄' : '垃圾桶'}</span>
                                </div>
                            </div>

                            <div className="lg:col-span-8 flex flex-col items-center">
                                <div className="h-12 flex items-center gap-4 mb-2">
                                    {hasOverlap && <div className="px-6 py-2 rounded-full bg-red-500 text-white flex items-center gap-2 animate-pulse shadow-lg font-bold"><Icon name="layers" /> 有神板發生重疊</div>}
                                    {hasPlacementError && <div className="px-6 py-2 rounded-full bg-orange-500 text-white flex items-center gap-2 shadow-lg font-bold"><Icon name="alert-triangle" /> 超出核心區域</div>}
                                </div>

                                <div className="relative bg-slate-950 p-6 rounded-[2.5rem] border-[10px] border-slate-800 shadow-2xl" onMouseLeave={() => setHoverPos(null)}>
                                    <div className="grid gap-[6px]" style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, ${CELL_DISPLAY_SIZE}px)` }}>
                                        {[...Array(GRID_SIZE * GRID_SIZE)].map((_, i) => {
                                            const r = Math.floor(i / GRID_SIZE), c = i % GRID_SIZE;
                                            return <div key={i} onMouseEnter={() => setHoverPos({r, c})} onClick={() => onCellClick(r, c)} className={`w-[${CELL_DISPLAY_SIZE}px] h-[${CELL_DISPLAY_SIZE}px] rounded-lg border border-slate-700/30 cursor-pointer transition-colors ${isOriginalZone(r, c) ? 'bg-slate-800 shadow-inner hover:bg-slate-700/50' : 'bg-slate-900/30'}`} style={{ width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE }} />
                                        })}
                                    </div>
                                    <div className="absolute inset-0 p-6 pointer-events-none z-30">
                                        <div className="grid gap-[6px]" style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, ${CELL_DISPLAY_SIZE}px)` }}>
                                            {gridOccupancy.map((row, r) => row.map((count, c) => count > 1 && (
                                                <div key={`${r}-${c}`} className="rounded-lg flex items-center justify-center border-2 border-red-400 border-dashed" style={{ width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE, backgroundColor: `rgba(239, 68, 68, ${Math.min(0.3 + (count - 1) * 0.25, 0.9)})` }}>
                                                    <span className="text-white text-xs font-black drop-shadow-md">{count}</span>
                                                </div>
                                            ) || <div key={`${r}-${c}`} style={{ width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE }} />))}
                                        </div>
                                    </div>
                                    {hoverPos && selectedType && (
                                        <div className="absolute inset-0 p-6 pointer-events-none z-40">
                                            {currentCells.map(([dr, dc], idx) => {
                                                const nr = hoverPos.r - grabOffset.r + dr, nc = hoverPos.c - grabOffset.c + dc;
                                                if (nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE) return null;
                                                const overlap = gridOccupancy[nr][nc] > 0;
                                                return <div key={idx} className={`absolute rounded-lg border-2 shadow-2xl transition-all duration-75 ${overlap ? 'border-red-400' : 'border-white'}`} style={{ width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE, left: nc * (CELL_DISPLAY_SIZE + GAP), top: nr * (CELL_DISPLAY_SIZE + GAP), backgroundColor: overlap ? 'rgba(239, 68, 68, 0.5)' : `${selectedType.color}cc` }} />
                                            })}
                                        </div>
                                    )}
                                    <div className="absolute inset-0 p-6 pointer-events-none">
                                        {placedPieces.map(piece => (
                                            <div key={piece.instanceId} className="relative">
                                                {piece.cells.map(([dr, dc], ci) => {
                                                    const t = hasNeighbor(piece.cells, dr, dc, [-1, 0]), b = hasNeighbor(piece.cells, dr, dc, [1, 0]);
                                                    const l = hasNeighbor(piece.cells, dr, dc, [0, -1]), r = hasNeighbor(piece.cells, dr, dc, [0, 1]);
                                                    return <div key={ci} className="absolute z-20 border-[2.5px] border-white shadow-md transition-all duration-200" style={{ 
                                                        width: CELL_DISPLAY_SIZE, height: CELL_DISPLAY_SIZE, 
                                                        left: (piece.rootC + dc) * (CELL_DISPLAY_SIZE + GAP), 
                                                        top: (piece.rootR + dr) * (CELL_DISPLAY_SIZE + GAP), 
                                                        backgroundColor: piece.color,
                                                        borderTop: t ? 'none' : '', borderBottom: b ? 'none' : '', borderLeft: l ? 'none' : '', borderRight: r ? 'none' : '',
                                                        borderRadius: `${!t&&!l?'8px':'0'} ${!t&&!r?'8px':'0'} ${!b&&!r?'8px':'0'} ${!b&&!l?'8px':'0'}`
                                                    }} />
                                                })}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                <div className="mt-8 flex gap-6 text-[10px] font-bold text-slate-500 uppercase tracking-widest">
                                    <div className="bg-slate-800/50 px-3 py-1.5 rounded-lg border border-slate-700/50 flex gap-2"><kbd className="bg-slate-700 px-1 rounded text-slate-200">R</kbd> 旋轉</div>
                                    <div className="bg-slate-800/50 px-3 py-1.5 rounded-lg border border-slate-700/50 flex gap-2"><kbd className="bg-slate-700 px-1 rounded text-slate-200">M</kbd> 鏡像</div>
                                    <div className="bg-slate-800/50 px-3 py-1.5 rounded-lg border border-slate-700/50 flex gap-2"><kbd className="bg-slate-700 px-1 rounded text-slate-200">ESC</kbd> 丟棄</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>